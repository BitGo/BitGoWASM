#!/usr/bin/env node
/**
 * Extract sample PSBT/TX data from fixtures for the parser UI.
 *
 * This script reads fixture files and extracts:
 * - psbtBase64: unsigned or partially signed PSBT
 * - psbtBase64Finalized: fully signed PSBT
 * - extractedTransaction: raw transaction hex
 *
 * Usage: node scripts/extract-samples.js
 */

const fs = require("fs");
const path = require("path");

const FIXTURES_DIR = path.resolve(__dirname, "../src/fixtures/fixed-script");
const OUTPUT_FILE = path.resolve(__dirname, "../src/wasm-utxo/parser/samples.ts");

function extractSamples() {
  const samples = [];

  // Read fixture files
  const files = fs.readdirSync(FIXTURES_DIR).filter((f) => f.endsWith(".json") && f.startsWith("psbt"));

  for (const file of files) {
    const filePath = path.join(FIXTURES_DIR, file);
    const content = fs.readFileSync(filePath, "utf-8");

    let fixture;
    try {
      fixture = JSON.parse(content);
    } catch {
      console.warn(`Skipping invalid JSON: ${file}`);
      continue;
    }

    // Extract name from filename: psbt-lite.bitcoin.unsigned.json -> Bitcoin Lite (unsigned)
    const match = file.match(/^psbt(-lite)?\.(\w+)\.(\w+)\.json$/);
    if (!match) continue;

    const [, lite, network, state] = match;
    const networkName = network.charAt(0).toUpperCase() + network.slice(1);
    const stateName = state.charAt(0).toUpperCase() + state.slice(1);
    const liteLabel = lite ? " Lite" : "";

    // Add psbtBase64 (unsigned/halfsigned)
    if (fixture.psbtBase64 && state !== "fullsigned") {
      samples.push({
        name: `${networkName}${liteLabel} PSBT (${stateName})`,
        type: "psbt",
        data: fixture.psbtBase64,
      });
    }

    // Add psbtBase64Finalized (fullsigned)
    if (fixture.psbtBase64Finalized) {
      samples.push({
        name: `${networkName}${liteLabel} PSBT (Finalized)`,
        type: "psbt",
        data: fixture.psbtBase64Finalized,
      });
    }

    // Add extractedTransaction
    if (fixture.extractedTransaction) {
      samples.push({
        name: `${networkName}${liteLabel} TX (Extracted)`,
        type: "tx",
        data: fixture.extractedTransaction,
      });
    }
  }

  // Sort by name
  samples.sort((a, b) => a.name.localeCompare(b.name));

  return samples;
}

function generateTypeScript(samples) {
  const lines = [
    "/**",
    " * Sample PSBT/TX data extracted from test fixtures.",
    " * Auto-generated by scripts/extract-samples.js",
    " * DO NOT EDIT MANUALLY",
    " */",
    "",
    "export interface Sample {",
    "  name: string;",
    '  type: "psbt" | "tx";',
    "  data: string;",
    "}",
    "",
    "export const samples: Sample[] = [",
  ];

  for (const sample of samples) {
    lines.push("  {");
    lines.push(`    name: ${JSON.stringify(sample.name)},`);
    lines.push(`    type: ${JSON.stringify(sample.type)},`);
    lines.push(`    data: ${JSON.stringify(sample.data)},`);
    lines.push("  },");
  }

  lines.push("];");
  lines.push("");

  return lines.join("\n");
}

function main() {
  console.log("Extracting samples from fixtures...");

  const samples = extractSamples();
  console.log(`Found ${samples.length} samples`);

  const typescript = generateTypeScript(samples);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, typescript);
  console.log(`Written to ${OUTPUT_FILE}`);
}

main();

