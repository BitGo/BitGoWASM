# `wasm-bindgen` Usage

This crate exposes Rust functions via the `wasm-bindgen` crate and macros.

## Namespacing Pattern

Since `wasm-bindgen` flattens all exports to a single module by default, we use a **namespace struct pattern** to organize related functions into logical groups.

### Rust Side: Namespace Structs

Create empty structs with `#[wasm_bindgen]` to serve as namespaces, then implement static methods:

```rust
// address/mod.rs

#[wasm_bindgen]
pub struct AddressNamespace;

#[wasm_bindgen]
impl AddressNamespace {
    pub fn to_output_script_with_coin(address: &str, coin: &str) -> Result<Vec<u8>, WasmError> {
        // implementation
    }

    pub fn from_output_script_with_coin(
        script: &[u8],
        coin: &str,
        format: Option<String>,
    ) -> Result<String, WasmError> {
        // implementation
    }
}
```

### Key Conventions

1. **Naming**: Use `*Namespace` suffix for namespace structs (e.g., `AddressNamespace`, `UtxolibCompatNamespace`)

2. **Structure**: Empty structs with no fields - they exist purely for organization

3. **Methods**: All functions are static methods on the namespace struct

4. **Case**: Use `snake_case` for method names (Rust convention) - they'll be available as both `snake_case` and `camelCase` in JavaScript

5. **Error Handling**: Return `Result<T, E>` types - `wasm-bindgen` automatically converts these to JavaScript exceptions

### Generated TypeScript

The Rust namespace struct becomes a TypeScript class with static methods:

```typescript
// wasm/wasm_utxo.d.ts (generated by wasm-bindgen)
export class AddressNamespace {
  private constructor();
  static to_output_script_with_coin(address: string, coin: string): Uint8Array;
  static from_output_script_with_coin(
    script: Uint8Array,
    coin: string,
    format?: string | null,
  ): string;
}
```

### TypeScript Wrapper Layer

The generated types have limitations (loose types like `any`, `string | null`). We wrap them with better TypeScript types in the `js/` directory.

**See `../js/README.md` for the complete TypeScript wrapper pattern.**

The wrapper layer:

- Imports the generated namespace classes
- Defines precise TypeScript types (e.g., union types instead of `string`)
- Exports wrapper functions with strong type signatures
- Provides better IDE support and compile-time type checking

### Example Flow

1. **Rust**: Define `AddressNamespace` struct with static methods
2. **wasm-bindgen**: Generates `AddressNamespace` class in `wasm_utxo.d.ts`
3. **TypeScript Wrapper**: `address.ts` wraps it with precise types
4. **Main Export**: `index.ts` exports it as `export * as address from "./address"`

This three-layer approach gives us:

- Clear organization in Rust
- Automatic WASM bindings
- Type-safe, well-documented TypeScript API

## Type Mapping

Common Rust â†” JavaScript type mappings:

| Rust               | JavaScript/TypeScript | Notes                          |
| ------------------ | --------------------- | ------------------------------ |
| `&str`, `String`   | `string`              | Strings are copied             |
| `&[u8]`, `Vec<u8>` | `Uint8Array`          | Efficient binary data          |
| `u32`, `i32`, etc. | `number`              | JavaScript numbers are f64     |
| `bool`             | `boolean`             |                                |
| `Option<T>`        | `T \| undefined`      | Becomes optional parameter     |
| `Result<T, E>`     | `T` (throws on Err)   | Errors become exceptions       |
| Custom structs     | `any` (usually)       | Reason for TypeScript wrappers |

## Best Practices

1. **Keep namespace structs empty** - They're purely for organization

2. **Use descriptive namespace names** - Clear what domain they cover (e.g., `AddressNamespace`, `PsbtNamespace`)

3. **Return `Result` types** - Let `wasm-bindgen` handle error conversion to JavaScript exceptions

4. **Avoid complex types in signatures** - Stick to primitives and byte arrays when possible; use `JsValue` for complex types

5. **Document with Rust doc comments** - They'll appear in the generated TypeScript

6. **Coordinate with TypeScript wrappers** - Keep the wrapper layer in mind when designing the Rust API
