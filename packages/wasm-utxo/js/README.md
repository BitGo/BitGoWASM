# Purpose

The primary purpose of this directory is to expose better TypeScript signatures than those
generated by the `wasm-pack` command (which uses `wasm-bindgen`).

While the `wasm-bindgen` crate allows some customization of the emitted type signatures, it
is a bit painful to use and has certain limitations that cannot be easily worked around.

## Architecture Pattern

This directory implements a **namespace wrapper pattern** that provides a cleaner, more
type-safe API over the raw WASM bindings.

### Pattern Overview

1. **WASM Generation** (`wasm/wasm_utxo.d.ts`)

   - Generated by `wasm-bindgen` from Rust code
   - Exports classes with static methods (e.g., `AddressNamespace`, `UtxolibCompatNamespace`)
   - Uses loose types (`any`, `string | null`) due to WASM-bindgen limitations

2. **Namespace Wrapper Files** (e.g., `address.ts`, `utxolibCompat.ts`, `fixedScriptWallet.ts`)

   - Import the generated WASM namespace classes
   - Define precise TypeScript types to replace `any` types
   - Export individual functions that wrap the static WASM methods
   - Re-export related types for convenience

3. **Shared Type Files** (e.g., `coinName.ts`, `triple.ts`)

   - Define common types used across multiple modules
   - Single source of truth to avoid duplication
   - Imported by wrapper files as needed

4. **Main Entry Point** (`index.ts`)
   - Uses `export * as` to group related functionality into namespaces
   - Re-exports shared types for top-level access
   - Augments WASM types with additional TypeScript declarations

### Example

Given a WASM-generated class:

```typescript
// wasm/wasm_utxo.d.ts (generated)
export class AddressNamespace {
  static to_output_script_with_coin(address: string, coin: string): Uint8Array;
  static from_output_script_with_coin(
    script: Uint8Array,
    coin: string,
    format?: string | null,
  ): string;
}
```

We create a wrapper module:

```typescript
// address.ts
import { AddressNamespace } from "./wasm/wasm_utxo";
import type { CoinName } from "./coinName";

export type AddressFormat = "default" | "cashaddr";

export function toOutputScriptWithCoin(address: string, coin: CoinName): Uint8Array {
  return AddressNamespace.to_output_script_with_coin(address, coin);
}

export function fromOutputScriptWithCoin(
  script: Uint8Array,
  coin: CoinName,
  format?: AddressFormat,
): string {
  return AddressNamespace.from_output_script_with_coin(script, coin, format);
}
```

And expose it via the main entry point:

```typescript
// index.ts
export * as address from "./address";
```

### Benefits

- **Type Safety**: Replace loose `any` and `string` types with precise union types
- **Better DX**: IDE autocomplete works better with concrete types
- **Maintainability**: Centralized type definitions prevent duplication
